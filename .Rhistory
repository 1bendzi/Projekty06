# Pakiet formatR
install.packages("formatR")
library(formatR)
# Porzadkowanie kodu - interfejs graficzny
tidy.gui()
getwd() # Ewentualna zmiana katalogu roboczy poprzez funkcję setwd
# Porzadkowanie kodu i zrzut do konsoli
tidy.source("pl_geom.R")
# Porzadkowanie kodu i zapis do pliku
tidy.source("pl_geom.R", file = "output.R")
# Alternatywnie
adr <- "http://wizard.uek.krakow.pl/~d701/mo/pl_geom.r"
tidy.source(adr)
tidy.source(adr, file = "output.R")
# Pakiet knitr (Literate programming)
# Wyciagnięcie kodu z dokumentu z rozszerzeniem Rnw (pliki łaczace kod R i LaTeX)
purl("ro.Rnw")
########################################################
# Maksymalizacja - zadanie PL - metoda geometryczna
########################################################
maxgeom <- function(A, b, c) {
d <- dim(A)[1]
m <- b/A[, 2]
sta <- m
f <- cbind(0, m)
rownames(f) <- paste(0, 1:d, sep = ",")
n <- b/A[, 1]
kier <- -m/n
e <- cbind(n, 0)
rownames(e) <- paste(1:d, 0, sep = ",")
a <- r <- NULL
for (i in 1:(d - 1)) {
for (j in (i + 1):d) {
g <- solve(A[c(i, j), ], b[c(i, j), ])
a <- rbind(a, g)
r <- rbind(r, paste(i, j, sep = ","))
}
rownames(a) <- r
}
pkt <- rbind(f, e, a)
lpkt <- dim(pkt)[1]
mi <- sapply(1:lpkt, function(i) min(sta + kier * pkt[i, 1]))
przec <- pkt[pkt[, 1] >= 0 & pkt[, 2] >= 0 & abs(pkt[, 2] - mi) < .Machine$double.eps^0.5,
]
lprzec <- dim(przec)[1]
sympl <- przec[order(przec[, 1], przec[, 2]), ]
if (sympl[1, 1] == 0) {
sympl <- rbind(rep(0, 2), sympl)
rownames(sympl)[1] <- "0,0"
}
colnames(sympl) <- colnames(pkt) <- c("x1", "x2")
z <- przec %*% c
rank <- cbind(przec, z)[order(z, decreasing = TRUE), ]
colnames(rank) <- c("x1", "x2", "Z")
plot(NULL, xlim = c(0, 1.1 * max(pkt[, 1])), ylim = c(0, 1.1 * max(pkt[, 2])),
xlab = "x1", ylab = "x2", main = "Zagadnienie maksymalizacji")
sapply(1:d, function(i) abline(sta[i], kier[i]))
polygon(sympl, col = "lightgrey")
points(rank[, 1:2], bg = c("black", "red")[1 + (rank[, 3] == rank[1, 3])], pch = 21)
op <- sapply(1:dim(rank)[1],
function(i) paste(paste(c("W:", "x1=", "x2=", "Z="),
c(rownames(rank)[i], signif(rank[i, ], 3)), sep = ""), collapse = ", "))
text(rank, op, pos = 4, cex = 0.7)
text(x = rep(0, d), y = sta, paste("(", 1:d, ")", sep = ""), pos = 2,
cex = 0.8, offset = 0.25)
list(A = A, b = b, c = c, sta = sta, kier = kier, pkt = pkt, sympl = sympl,
rank = rank)
}
##############################################################################
# Wykreslanie warstwic maksymalizowanej funkcji celu w przestrzeni (x1, x2)
##############################################################################
# warstwice dla wybranych wartosci Z
warstw <- function(m, n = 5) {
k <- m$rank[1, 3]
c <- m$c
z <- seq(0, k, length.out = n)
sta <- z/c[2]
kier <- -c[1]/c[2]
xz <- z/c[1]
mm <- 1.1 * max(m$pkt[, 1])
for (i in 1:n) {
abline(sta[i], kier, lty = 2, col = "darkgreen", lwd = 1.5)
t <- ifelse(xz[i] < mm, 0.85 * xz[i], 0.85 * mm)
text(x = t, y = sta[i] + kier * t, paste("Z=", signif(z[i], 3),
sep = ""), pos = 4, cex = 0.8, col = "darkgreen")
}
list(c = c, Z = z, pk = cbind(sta = sta, kier = kier))
}
# warstwice Z przechodzace przez dopuszczalne punkty wierzcholkowe
warstwsim <- function(m) {
z <- m$rank[, 3]
c <- m$c
sta <- z/c[2]
kier <- -c[1]/c[2]
xz <- z/c[1]
mm <- 1.1 * max(m$pkt[, 1])
for (i in 1:length(z)) {
abline(sta[i], kier, lty = 2, col = "darkred", lwd = 1.5)
t <- ifelse(xz[i] < mm, 0.85 * xz[i], 0.85 * mm)
text(x = t, y = sta[i] + kier * t, paste("Z=", signif(z[i], 3),
sep = ""), pos = 4, cex = 0.8, col = "darkred")
}
list(c = c, Z = z, pk = cbind(sta = sta, kier = kier))
}
#########################################################################################
# Trójwymiarowy wykres funkcji celu wraz z oznaczonym zbiorem rozwiazań dopuszczalnych
#########################################################################################
troj <- function(m) {
c <- m$c
x <- c(0, 1.1 * max(m$pkt[, 1]))
y <- c(0, 1.1 * max(m$pkt[, 2]))
z <- function(x = x, y = y) c[1] * x + c[2] * y
my <- outer(x, y, z)
res <- persp(z = my, col = "grey", phi = 0, theta = -30, ticktype = "detailed",
xlab = "x1", ylab = "x2", zlab = "Z", main = "Wykres funkcji celu z oznaczonym ZRD")
sympl <- rbind(m$sympl, m$sympl[1, ])
s1 <- sympl[, 1]/(1.1 * max(m$pkt[, 1]))
s2 <- sympl[, 2]/(1.1 * max(m$pkt[, 2]))
s3 <- z(sympl[, 1], sympl[, 2])
lines(trans3d(x = s1, y = s2, z = s3, pmat = res), col = "red", lwd = 2)
}
### Przykład zadania maksymalizacji
### max Z=3*x1 + 4*x2
### p.w.  4*x1 + 2*x2 <= 7
### 2*x1 + 4*x2 <= 6
### x1 + 4*x2 <= 5
### x1 >= 0, x2 >= 0
A <- matrix(c(4, 2, 1, 2, 4, 4), ncol = 2)
b <- matrix(c(7, 6, 5))
c <- 3:4
###############################################################
# Pseudolosowe generowanie parametrów zadania maksymalizacji PL
###############################################################
los <- function(par = c(2, 5), d = 2) {
przec <- matrix(rep(0, 2))
while (any(przec <= 0)) {
A <- matrix(runif(4, par[1], par[2]), ncol = 2)
par <- runif(1, 1.5, 3) * par
b <- matrix(runif(2, par[1], par[2]))
bb <- matrix(runif(1, par[1], par[2]))
przec <- solve(A, b)
}
yn1 <- runif(1, przec[2, ], min(b/A[, 2]))
xn1 <- runif(1, 0.1 * przec[1, ], przec[1, ])
z1 <- c(xn1, yn1)
z2 <- c(przec[1, ], runif(1, przec[2, ], yn1))
AA <- solve(rbind(z1, z2), matrix(rep(bb, 2)))
A <- round(rbind(A, t(AA)), d)
b <- round(rbind(b, bb), d)
list(A = A, b = b)
}
lo <- los(d = 2)
m <- maxgeom(lo$A, lo$b, 1:2)
install.packages("topicmodels")
install.packages("wordcloud")
load("C:/Users/Beniamin/Desktop/Git/Projekty06/workspaces/po_zrobieniu_wykresu_pca.RData")
load("C:/Users/Beniamin/Desktop/Git/Projekty06/workspaces/po_zrobieniu_wykresu_pca.RData")
setwd("~/")
workDir <- "C:\\Users\\Beniamin\\Desktop\\Git\\Projekty06"
#utworzenie macierzy częstości
tdmTfAll <- TermDocumentMatrix(corpus)
dtmTfAll <- DocumentTermMatrix(corpus)
tdmTfidfAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf
)
)
tdmBinAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightBin
)
)
tdmTfBounds <- TermDocumentMatrix(
corpus,
control = list(
bounds = list(
global = c(5,10)
)
)
)
tdmTfidfBounds <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(5,10)
)
)
)
dtmTfidfBounds <- DocumentTermMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(5,10)
)
)
)
#konwersja macierzy żadkich do macierzy klasycznych
tdmTfAllMatrix <- as.matrix(tdmTfAll)
dtmTfAllMatrix <- as.matrix(dtmTfAll)
tdmTfidfAllMatrix <- as.matrix(tdmTfidfAll)
tdmBinAllMatrix <- as.matrix(tdmBinAll)
tdmTfBoundsMatrix <- as.matrix(tdmTfBounds)
tdmTfidfBoundsMatrix <- as.matrix(tdmTfidfBounds)
dtmTfidfBoundsMatrix <- as.matrix(dtmTfidfBounds)
#eksport macirzy do pliku .csv
matrixFile <- paste(
outputDir,
"\\",
"tdmTfidfBounds(5,10).csv",
sep = ""
)
write.table(tdmTfidfBoundsMatrix, file = matrixFile, sep = ";", dec = ",", col.names = NA)
#wĹ‚Ä…czenie bibliotek
library(tm)
library (hunspell)
library (stringr)
#zmiana katalogu roboczego
workDir <- "C:\\Users\\Beniamin\\Desktop\\Git\\Projekty06"
setwd(workDir)
#definicja katalogow projektu
inputDir <- ".\\data"
outputDir <- ".\\results"
scriptsDir <- ".\\scripts"
workspaceDir <- ".\\workspaces"
tdmTfAll <- TermDocumentMatrix(corpus)
dtmTfAll <- DocumentTermMatrix(corpus)
tdmTfidfAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf
)
)
tdmBinAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightBin
)
)
tdmTfBounds <- TermDocumentMatrix(
corpus,
control = list(
bounds = list(
global = c(5,10)
)
)
)
tdmTfidfBounds <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(5,10)
)
)
)
dtmTfidfBounds <- DocumentTermMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(5,10)
)
)
)
#konwersja macierzy żadkich do macierzy klasycznych
tdmTfAllMatrix <- as.matrix(tdmTfAll)
dtmTfAllMatrix <- as.matrix(dtmTfAll)
tdmTfidfAllMatrix <- as.matrix(tdmTfidfAll)
tdmBinAllMatrix <- as.matrix(tdmBinAll)
tdmTfBoundsMatrix <- as.matrix(tdmTfBounds)
tdmTfidfBoundsMatrix <- as.matrix(tdmTfidfBounds)
dtmTfidfBoundsMatrix <- as.matrix(dtmTfidfBounds)
#eksport macirzy do pliku .csv
matrixFile <- paste(
outputDir,
"\\",
"tdmTfidfBounds(5,10).csv",
sep = ""
)
write.table(tdmTfidfBoundsMatrix, file = matrixFile, sep = ";", dec = ",", col.names = NA)
#utworzenie macierzy częstości
tdmTfAll <- TermDocumentMatrix(corpus)
dtmTfAll <- DocumentTermMatrix(corpus)
tdmTfidfAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf
)
)
tdmBinAll <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightBin
)
)
tdmTfBounds <- TermDocumentMatrix(
corpus,
control = list(
bounds = list(
global = c(3,18)
)
)
)
tdmTfidfBounds <- TermDocumentMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(3,18)
)
)
)
dtmTfidfBounds <- DocumentTermMatrix(
corpus,
control = list(
weighting = weightTfIdf,
bounds = list(
global = c(3,18)
)
)
)
#konwersja macierzy żadkich do macierzy klasycznych
tdmTfAllMatrix <- as.matrix(tdmTfAll)
dtmTfAllMatrix <- as.matrix(dtmTfAll)
tdmTfidfAllMatrix <- as.matrix(tdmTfidfAll)
tdmBinAllMatrix <- as.matrix(tdmBinAll)
tdmTfBoundsMatrix <- as.matrix(tdmTfBounds)
tdmTfidfBoundsMatrix <- as.matrix(tdmTfidfBounds)
dtmTfidfBoundsMatrix <- as.matrix(dtmTfidfBounds)
#eksport macirzy do pliku .csv
matrixFile <- paste(
outputDir,
"\\",
"tdmTfidfBounds(3,18).csv",
sep = ""
)
write.table(tdmTfidfBoundsMatrix, file = matrixFile, sep = ";", dec = ",", col.names = NA)
#wĹ‚Ä…czenie bibliotek
library(tm)
library (hunspell)
library (stringr)
#zmiana katalogu roboczego
workDir <- "C:\\Users\\Beniamin\\Desktop\\Git\\Projekty06"
setwd(workDir)
#definicja katalogow projektu
inputDir <- ".\\data"
outputDir <- ".\\results"
scriptsDir <- ".\\scripts"
workspaceDir <- ".\\workspaces"
dir.create(outputDir, showWarnings = FALSE)
dir.create(workspaceDir, showWarnings = FALSE)
#utworzenie korpusu dokumentow
corpusDir <- paste(
inputDir,
"Literatura - oryginal",
sep = "\\"
)
corpus <- VCorpus(
DirSource(
corpusDir,
pattern = "*.txt",
encoding = "UTF-8"
),
readerControl = list(
language = "pl_PL"
)
)
#wstepne przetwarzanie: usunięcie z podziału na akapity
pasteParagraphs <- content_transformer(function(x,char) paste(x, collapse = char))
corpus <- tm_map(corpus, pasteParagraphs, " ")
#wstepne przetwarzanie: stoplista
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, content_transformer(tolower))
stoplistFile <- paste(
inputDir,
"stopwords_pl.txt",
sep = "\\"
)
stoplist <- readLines(stoplistFile, encoding = "UTF-8")
corpus <- tm_map(corpus, removeWords, stoplist)
corpus <- tm_map(corpus, stripWhitespace)
#wstepne przetwarzanie: usuniecie em dash i 3/4
removeChar <- content_transformer(function(x,pattern) gsub(pattern, "", x))
corpus <- tm_map(corpus, removeChar, intToUtf8(8722))
corpus <- tm_map(corpus, removeChar, intToUtf8(190))
#wstepne przetwarzanie: lemantyzacja
polish <- dictionary(lang="pl_PL")
lemmatize <- function(text) {
simpleText <- str_trim(as.character(text))
parsedText <- strsplit(simpleText, split = " ")
newTextVec <- hunspell_stem(parsedText[[1]], dict = polish)
for (i in 1:length(newTextVec)) {
if (length(newTextVec[[i]]) == 0) newTextVec[i] <- parsedText[[1]][i]
if (length(newTextVec[[i]]) > 1) newTextVec[i] <- newTextVec[[i]][1]
}
newText <- paste(newTextVec, collapse = " ")
return(newText)
}
corpus <- tm_map(corpus, content_transformer(lemmatize))
#wstepne przetwarzanie: usuniecie rozszerzen
cutExtensions <- function(document){
meta(document, "id") <- gsub(pattern = "\\.txt$", replacement = "", meta(document, "id"))
return(document)
}
corpus <- tm_map(corpus, cutExtensions)
#eksport korpusu przetworzonego do plików tekstowych
preprocessedDir <- paste(
outputDir,
"\\",
"Literatura - streszczenia - przetworzone",
sep = ""
)
dir.create(preprocessedDir, showWarnings = FALSE)
writeCorpus(corpus, path = preprocessedDir)
